:PROPERTIES:
:ID:       0d27941b-353e-4a88-9390-4d9c12fd6058
:END:
#+title: Oz
#+filetags: :oz:

* Introduction to Programming Concepts

** Variables

#+begin_quote
The declare statement creates a new store variable and makes the variable
identifier refer to it. Previous calculations using the same identifier are not
changed because the identifier refers to another store variable.

[cite:@van2004concepts p.2 chap.1 part.1.2]
#+end_quote

#+begin_src oz
  declare
  V=9999*9999
#+end_src

** Functions

#+begin_quote
The declare statement creates the new variable Fact.The fun statement defines a
function. The variable Fact is bound to the function.The function has one
argument N, which is a local variable, i.e., it is known only inside the
function body. Each time we call the function a new local variable is created.

[cite:@van2004concepts p.2-3 chap.1 part.1.3]
#+end_quote


#+begin_src oz
  declare
  fun {Fact N}
    if N==0 then 1 else N*{Fact N-1} end
  end
#+end_src

** Recursion

*** Combinations

#+begin_src oz
  declare
  fun {Comb N K}
    {Fact N} div ({Fact K}*{Fact N-K})
  end
#+end_src

** Lists

*** Pattern Matching

#+begin_src oz
declare
L=[5 6 7 8]
case L of H|T then {Browse H} {Browse T} end
#+end_src

** Functions over Lists

** Correctness 

#+begin_quote
To prove correctness in general, we have to reason about the program. This means
three things:

+ We need a mathematical model of the operations of the programming language,
  defining what they should do.This model is called the language’s semantics.
+ We need to define what we would like the program to do.Usually, this is a
  mathematical definition of the inputs that the program needs and the output
  that it calculates. This is called the program’s specification.
+ We use mathematical techniques to reason about the program, using the
  semantics. We would like to demonstrate that the program satisfies the
  specification.

A program that is proved correct can still give incorrect results, if the system
on which it runs is incorrectly implemented.

[cite:@van2004concepts p.9 chap.1 part.1.6]
#+end_quote

** Complexity


** Lazy Evaluation

#+begin_src oz
  fun lazy {Ints N}
    N|{Ints N+1}
  end
#+end_src

** Higher-Order Programming

** Concurrency

#+begin_src oz
  thread P in
    P={Pascal 30}
    {Browse P}
  end
  {Browse 99*99}
#+end_src

** Dataflow

#+begin_quote
What happens if an operation tries to use a variable that is not yet bound? From
a purely aesthetic point of view, it would be nice if the operation would simply
wait. Perhaps some other thread will bind the variable, and then the operation
can continue.This civilized behavior is known as dataflow.

(...)

Adding threads and delays to a program can radically change a program’s
appearance. But as long as the same operations are invoked with the same
arguments, it does not change the program’s results at all. This is the key
property of dataflow concurrency.This is why dataflow concurrency gives most of
the advantages of concurrency without the complexities that are usually
associated with it.

[cite:@van2004concepts p.15-16.1 part.1.11]
#+end_quote

#+begin_src oz
declare X in
thread {Delay 10000} X=99 end
{Browse start} {Browse X*X}
#+end_src

** Explicit state
*** Memory Cell

#+begin_quote
There are lots of ways to define explicit state.The simplest way is to define a
single memory cell. This is a kind of box in which you can put any content. Many
programming languages call this a "variable". We call it a "cell" to avoid
confusion with the variables we used before, which are more like mathematical
variables, i.e., just shortcuts for values.

[cite:@van2004concepts p.16-17 chap.1 part.1.12]
#+end_quote

#+begin_src oz
declare
C={NewCell 0}
C:=@C+1
{Browse @C}
#+end_src

** Object

#+begin_src oz
declare
local C in
  C={NewCell 0}
  fun {Bump}
    C:=@C+1
    @C
  end
  fun {Read}
    @C
  end
end
#+end_src

** Classes

#+begin_src oz
declare
fun {NewCounter}
  C Bump Read in
  C={NewCell 0}

  fun {Bump}
    C:=@C+1
    @C
  end

  fun {Read}
    @C
  end

  counter(bump:Bump read:Read)
end
#+end_src

** Atomicity

#+begin_src oz
declare
C={NewCell 0}
L={NewLock}

thread
  lock L then I in
    I=@C
    C:=I+1
  end
end

thread
  lock L then J in
    J=@C
    C:=J+1
  end
end
#+end_src

