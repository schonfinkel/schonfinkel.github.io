:PROPERTIES:
:ID:       60f014f9-8a82-43b8-ae13-dee68b9470bf
:END:
#+title: Statements (PostgreSQL)
#+filetags: :postgresql: :sql:

- [[id:1949c98e-e1c0-474b-b383-c76aa418d583][PostgreSQL]]

* ~SELECT~
** ~LIKE~ and ~ILIKE~
** ~DISTINCT~
** ~LIMIT~ and ~OFFSET~

#+begin_quote
~LIMIT~ and ~OFFSET~ are used to return a portion of data from a resultset
generated by a query; the ~LIMIT~ clause is used to limit the number of records in
output and the ~OFFSET~ clause is used to provide PostgreSQL with the position in
the resultset from which to start returning data.

[cite:@ferrari2023postgres p.111]
#+end_quote

* Subqueries

+ Subqueries return a set.

** Subqueries as Expressions

*** Scalar Subquery
Results in a single row.

*** Multi-Row Subquery
Results in multiple rows, tipically used in the where clause with operators such
as ~IN~, ~NOT~, ~EXISTS~, ~ANY~ and ~ALL~.

**** Correlated Subquery
A uncorrelated sub-query is a type of sub-query where the inner query doesnâ€™t
depend upon the outer query for its execution.

#+begin_src sql
  SELECT
    foo,
    (SELECT
      AVG(...)
     FROM B
     WHERE B.foo = A.foo) AS bar
  FROM A;
#+end_src

**** Uncorrelated Subquery
A correlated sub-query is a type of query where the inner query depends upon the
outcome of the outer query in order to perform its execution.

#+begin_src sql
  SELECT
    foo,
    (SELECT
      AVG(...)
     FROM B) AS bar
  FROM A;
#+end_src

** Subqueries as Tables

** Semi-Joins & Subquery Elimination

#+begin_quote
A semi-join between two tables R and S returns rows from table R for which there
is at least one row from table S with matching values in the joining columns.

[cite:@dombrovskaya2021postgresql p.138]
#+end_quote

* ~JOIN~

** Cross Join

#+begin_src sql
  SELECT <...>
  FROM table1, table2
  -- or
  SELECT <...>
  FROM table1 CROSS JOIN table2
#+end_src

** Inner Join

** Outter Join

+ ~FULL~
+ ~LEFT~
+ ~RIGHT~
  
** Lateral Join

#+begin_quote
A lateral join is a type of join in SQL that allows you to join a table with a
subquery, where the subquery is run for each row of the main table.
[cite:@ferrari2023postgres p.129]
#+end_quote

* Aggregate Functions

** ~GROUP BY~

#+begin_quote
Aggregate functions are used in conjunction with the group by clause. A group by
clause splits a resultset into groups of rows and aggregate functions perform
calculations on them. [cite:@ferrari2023postgres p.131]
#+end_quote

| Function              | Description |
|-----------------------+-------------|
| ~AVG()~                 |             |
| ~COUNT()~               |             |
| ~MAX()~                 |             |
| ~MIN()~                 |             |
| ~SUM()~                 |             |
| ~ARRAY_AGG~             |             |
| ~JSON_AGG~ or ~JSONB_AGG~ |             |
| ~BOOL_AND(Predicate)~   |             |
| ~BOOL_OR(Predicate)~    |             |

#+begin_src sql
  SELECT category, COUNT(*)
  FROM posts
  GROUP BY category;
  -- Outputs:
   category | count
  ----------+-------
          3 | 1
          1 | 2
#+end_src

You can also filter the result of a ~GROUP BY~ by using ~HAVING~:

#+begin_src sql
  SELECT category, COUNT(*)
  FROM posts
  GROUP BY category
  HAVING COUNT(*) > 1;
#+end_src

and also pack multiple aggregations in a single ~SELECT~ statement:

#+begin_src sql
  SELECT
    category,
    COUNT(*),
    COUNT(*) FILTER (WHERE replies > 2) as number_of_replies
  FROM posts
  GROUP BY category
  HAVING COUNT(*) > 1;
#+end_src

*** ~GROUPING SETS~, ~CUBE~, and ~ROLLUP~

#+begin_quote
More complex grouping operations than those described above are possible using
the concept of grouping sets. The data selected by the ~FROM~ and ~WHERE~ clauses is
grouped separately by each specified grouping set, aggregates computed for each
group just as for simple GROUP BY clauses, and then the results returned.
#+end_quote

* Combining Queries

** ~UNION~ / ~UNION ALL~

#+begin_quote
The ~UNION~ operator is used to combine the resultset of two or more ~SELECT~
statements. We can use the ~UNION~ statement only if the following rules are
respected:
  + Each ~SELECT~ statement within ~UNION~ must have the same number of columns.
  + The columns must have similar data types.
  + The columns in each ~SELECT~ statement must be in the same order.

[cite:@ferrari2023postgres p.133]
#+end_quote

+ ~UNION~ is an alias to ~UNION DISTINCT~.

** ~EXCEPT~ / ~INTERSECT~

* Upsert

#+begin_quote
In PostgreSQL, the ~UPSERT~ statement does not exist as in other DBMSes. An ~UPSERT~
statement is used when we want to insert a new record on top of the existing
record or update an existing record. 
#+end_quote

The optional ~ON CONFLICT~ clause specifies an alternative action to raising a
unique violation or exclusion constraint violation error:

#+begin_src sql
  INSERT INTO table_name(c1, c2, ..., cn) VALUES(v1, v2, ..., vn)
  ON CONFLICT (...);
#+end_src

and the conflict action can be either:

+ ~DO NOTHING~.
+ ~DO UPDATE~ + (~SET~ and/or ~WHERE~)

#+begin_src sql
  INSERT INTO table_name(c1, c2, ..., cn) VALUES(v1, v2, ..., vn)
  ON CONFLICT
  DO UPDATE SET c1 = EXCLUDED.v1;
#+end_src

where ~EXCLUDED~ references the proposed new insertion row.

* ~RETURNING~

Reduces the need for an extra query as it enables you to output columns.

** Inserts
** Updates
** Deletes

* Common Table Expressions

#+begin_quote
A ~CTE~, or a common table expression, is a temporary result taken from a [[id:11f7d9cc-51a6-4897-955b-37a756105677][SQL]]
statement. This statement can contain ~SELECT~, ~INSERT~, ~UPDATE~, or ~DELETE~
instructions. The lifetime of a ~CTE~ is equal to the lifetime of the query.

[cite:@ferrari2023postgres p.145]
#+end_quote

** CTEs in PostgreSQL 12+

#+begin_quote
Starting from PostgreSQL version 12, things have changed, and two new options
have been introduced for the execution of a CTE, namely ~MATERIALIZED~ and ~NOT
MATERIALIZED~.

[cite:@ferrari2023postgres p.146]
#+end_quote

** Recursive

#+BEGIN_COMMENT
A recursive CTE is a special construct that allows an auxiliary statement to
reference itself and, therefore, join itself onto previously computed
results. This is particularly useful when we need to join a table an unknown
number of times, typically to "explode" a flat tree structure. The traditional
solution would involve some kind of iteration, probably by means of a cursor
that iterates one tuple at a time over the whole resultset. However, with
recursive CTEs, we can use a much cleaner and simpler approach. A recursive CTE
is made by an auxiliary statement that is built on top of the following:

+ A non-recursive statement, which works as a bootstrap statement and is executed when the auxiliary term is first evaluated
+ A recursive statement, which can either reference the bootstrap statement or itself

[cite:@ferrari2023postgres p.150]
#+END_COMMENT

#+begin_src sql
  WITH RECURSIVE fib AS (
    SELECT 
      0 as level,
      0 as n,
      1 as m
    UNION ALL
    SELECT
      level + 1 as level,
      m as n,
      (n + m) as m
    FROM fib WHERE n < 10
  )
  SELECT * FROM fib;
  -- Outputs:
   level | n  | m  
  -------+----+----
       0 |  0 |  1
       1 |  1 |  1
       2 |  1 |  2
       3 |  2 |  3
       4 |  3 |  5
       5 |  5 |  8
       6 |  8 | 13
       7 | 13 | 21
#+end_src
