<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2025-08-30 Sat 11:35 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Distributed Erlang</title>
<meta name="author" content="Marcos Benevides" />
<meta name="generator" content="Org Mode" />
<link href="https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css" rel="stylesheet">
<!-- syntax highlighting -->
<link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/styles/default.min.css">
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/languages/erlang.min.js"></script>
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/languages/fsharp.min.js"></script>
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/languages/nix.min.js"></script>
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/languages/yaml.min.js"></script>
<!-- D3.js for the Org-roam graph -->
<script type="text/javascript" src ="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
<!-- For LaTeX -->
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="https://schonfinkel.github.io/static/css/main.css" rel="stylesheet">
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  // block
      inlineMath: [['\\(', '\\)']]                  // inline
    }
  };
</script>
</head>
<body>
<header id="preamble" class="status">
<nav>
  <img
    src="https://schonfinkel.github.io/static/img/logo.png"
    alt="logo"
    width="128"
    height="128"
  />
  <div>
    <h3>"Writing is nothing more than a guided dream."</h3>
  </div>
  <ul>
    <li><a href="https://schonfinkel.github.io/index.html">Home</a></li>
    <li><a href="https://schonfinkel.github.io/blog.html">Blog</a></li>
    <li><a href="https://schonfinkel.github.io/notes.html">Notes</a></li>
    <li><a href="https://schonfinkel.github.io/static/cv.pdf">CV</a></li>
    <li><a href="https://schonfinkel.github.io/static/blogroll.xml">BlogRoll</a></li>
    <li><a href="https://schonfinkel.github.io/rss.xml"><i class='bx bx-rss'></i></a></li>
  </ul>
</nav>
</header>
<main id="content" class="content">
<header>
<h1 class="title">Distributed Erlang</h1>
</header><blockquote>
<p>
<a href="20240619114451-erlang.html#ID-de7d0e94-618f-4982-b3e5-8806d88cad5d">Erlang</a> makes certain types of distributed programming extremely easy; in no time
at all, and with very little code, you can have a number of machines across a
network happily chatting with one another. Two fundamental features of Erlang
make this possible:
</p>
<ul class="org-ul">
<li>Process communication by copying</li>
<li>Location Transparency</li>
</ul>
<p>
(<a href="#citeproc_bib_item_2">Logan, Merritt, and Carlsson 2010, 191 chap.8 pt.8.1</a>)
</p>
</blockquote>


<figure id="orgbfbeb91">
<img src="../static/img/notes/distributed_erlang.png" alt="distributed_erlang.png">

</figure>
<div id="outline-container-orgfbe3780" class="outline-2">
<h2 id="orgfbe3780">Nodes and Clustering</h2>
<div class="outline-text-2" id="text-orgfbe3780">
<blockquote>
<p>
An Erlang node consists of several loosely coupled applications, (&#x2026;) combined
with other third-party applications and applications you write specifically for
the system you are trying to implement. These applications could be independent
of each other or rely on the services and APIs of other
applications. (<a href="#citeproc_bib_item_1">Cesarini and Vinoski 2016, 11</a>)
</p>
</blockquote>
</div>
<div id="outline-container-orge301cd4" class="outline-3">
<h3 id="orge301cd4">Starting a Node</h3>
<div class="outline-text-3" id="text-orge301cd4">
<p>
To start an Erlang node in distributed mode, you run <code>erl</code> with one of the flags
<code>-name</code> or <code>-sname</code>:
</p>
<div class="org-src-container">
<pre class="src src-shell">  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Used in normal environments with FQDN</span>
  erl &#8211;name node_name
  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Used when FQDNs don't work</span>
  erl &#8211;sname node_name
</pre>
</div>

<blockquote>
<p>
Nodes with short names and long names work in different communication modes and
can't be part of the same Erlang cluster. All connected nodes must use the same
mode. (<a href="#citeproc_bib_item_2">Logan, Merritt, and Carlsson 2010, 194 chap.8 pt.8.2.1</a>)
</p>
</blockquote>

<p>
Now, to connect multiple nodes:
</p>

<div class="org-src-container">
<pre class="src src-shell">  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">shell #1</span>
  erl &#8211;name a

  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">shell #2</span>
  erl &#8211;name b

  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">On shell #1</span>
  &gt; net_adm:ping(<span style="font-style: italic;">'b@here.net'</span>)
  &gt; pong

  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">On shell #2</span>
  &gt; nodes()<span style="font-weight: bold;">.</span> 
  &gt; [<span style="font-style: italic;">'a@here.net'</span>]
</pre>
</div>
</div>
</div>
<div id="outline-container-org94ea03e" class="outline-3">
<h3 id="org94ea03e">Naming and Communication</h3>
<div class="outline-text-3" id="text-org94ea03e">
<blockquote>
<p>
You can <code>spawn</code> and <code>link</code> to processes on any node in the system, not just locally,
using <code>link(Pid)</code>, <code>spawn(Node, Mod, Fun, Args)</code>, and <code>spawn_link</code>. If the call is
successful, <code>link</code> will return the atom true, while <code>spawn</code> returns the pid of the
process on the remote host. (<a href="#citeproc_bib_item_1">Cesarini and Vinoski 2016, 49</a>)
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org24dc057" class="outline-3">
<h3 id="org24dc057">Connecting Nodes</h3>
<div class="outline-text-3" id="text-org24dc057">
</div>
<div id="outline-container-org6ce852d" class="outline-4">
<h4 id="org6ce852d">Hidden Nodes</h4>
<div class="outline-text-4" id="text-org6ce852d">
<blockquote>
<p>
It's possible to connect clusters via special nodes to form a larger, not fully
connected cluster. Such nodes are configured not to propagate information about
other nodes, or even to be invisible to the other nodes, which can be useful for
nonintrusive inspection of a cluster. (<a href="#citeproc_bib_item_2">Logan, Merritt, and Carlsson 2010, 195 chap.8 pt.8.2.2</a>)
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org67a6617" class="outline-4">
<h4 id="org67a6617">EPMD</h4>
<div class="outline-text-4" id="text-org67a6617">
<blockquote>
<p>
EPMD is the Erlang Port Mapper Daemon. Whenever you start a node, the node
checks that EPMD is running on your local machine and starts it otherwise. EPMD
keeps track of which nodes are running on the local machine and what ports they
have been assigned. When an Erlang node on one machine wants to talk to a remote
node, the local EPMD talks to the EPMD on the remote machine (by default using
TCP/IP on port 4369) and asks if it has a node by that name up and running. If
so, the remote EPMD replies with the port used for communicating directly with
the remote node. But EPMDs never try to locate each other
automatically - communication must always be triggered by one node looking for
another. (<a href="#citeproc_bib_item_2">Logan, Merritt, and Carlsson 2010, 197 chap.8 pt.8.2.3</a>)
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-org458f3cf" class="outline-3">
<h3 id="org458f3cf">The Cookie Protection System</h3>
<div class="outline-text-3" id="text-org458f3cf">
<p>
For two distributed Erlang nodes to communicate, they must have the same magic cookie. We can set the cookie in three ways:
</p>
<ol class="org-ol">
<li>Store the same cookie in the file <code>$HOME/.erlang.cookie</code>.</li>
<li>Using the <code>-setcookie C</code> command line argument:</li>
</ol>
<div class="org-src-container">
<pre class="src src-shell">  erl -setcookie &lt;cookie&gt;
</pre>
</div>
<ol class="org-ol">
<li>The BIF <code>erlang:set_cookie(node(), C)</code> sets the cookie of the local node to the atom <code>C</code>.</li>
</ol>
</div>
</div>
<div id="outline-container-org080be0d" class="outline-3">
<h3 id="org080be0d">Sending messages between connected nodes</h3>
</div>
</div>
<div id="outline-container-org52dff6d" class="outline-2">
<h2 id="org52dff6d">Socket-Based Distribution</h2>
</div>

<div id="outline-container-org8a15689" class="outline-2">
<h2 id="org8a15689">References:</h2>
<div class="outline-text-2" id="text-org8a15689">
<style>.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}</style><div class="csl-bib-body">
  <div class="csl-entry"><a id="citeproc_bib_item_1"></a>Cesarini, Francesco, and Steve Vinoski. 2016. <i>Designing for Scalability with Erlang/Otp: Implement Robust, Fault-Tolerant Systems</i>. Oâ€™Reilly Media, Inc.</div>
  <div class="csl-entry"><a id="citeproc_bib_item_2"></a>Logan, Martin, Eric Merritt, and Richard Carlsson. 2010. <i>Erlang and Otp in Action</i>. Manning Publications Co.</div>
</div>
</div>
</div>
</main>
<footer id="postamble" class="status">
<footer>
  </br>
  <p>
  Built with <a href="https://orgmode.org/">Orgmode</a>, <a href="https://www.gnu.org/software/emacs/">Emacs</a> and <a href="https://nixos.org/">Nix</a>, source code availiable <a href="https://github.com/schonfinkel/schonfinkel.github.io">here</a>.
  </p>
</footer>
</footer>
</body>
</html>
