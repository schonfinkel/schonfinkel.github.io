<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
     xmlns:georss="http://www.georss.org/georss"
     xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"
     xmlns:media="http://search.yahoo.com/mrss/"><channel>
  <title>Some experiments with Erlang and NixOS</title>
  <atom:link href="https://schonfinkel.github.io/blog/20240907-experiments_with_erlang_and_nix.xml" rel="self" type="application/rss+xml" />
  <link>https://schonfinkel.github.io/blog</link>
  <description><![CDATA[]]></description>
  <language>en</language>
  <pubDate>Mon, 08 Sep 2025 13:07:01 +0000</pubDate>
  <lastBuildDate>Mon, 08 Sep 2025 13:07:01 +0000</lastBuildDate>
  <generator>Emacs 30.1 Org-mode 9.7.30</generator>
  <webMaster>runner@pkrvm7jw40e0xgp (Marcos Benevides)</webMaster>
  <image>
    <url>https://orgmode.org/img/org-mode-unicorn-logo.png</url>
    <title>Some experiments with Erlang and NixOS</title>
    <link>https://schonfinkel.github.io/blog</link>
  </image>

  <ul class="org-ul">
    <li><b>Updated at </b>: I've changed the way we package our erlang project</li>
  </ul>
  <p>
    with Nix, mostly for the better.
  </p>
  <ul class="org-ul">
    <li><b>Updated at </b>: I've also changed the way we build the Zig</li>
  </ul>
  <p>
    client.
  </p>
  <ul class="org-ul">
    <li><b>Updated at </b>: My friend Lemos actually did a presentation of
    some of our internal tooling <code>zerl</code> on <a href="https://www.youtube.com/@FuncProgSweden/videos">Func Prog Sweden</a>, you can watch the demo
    of version <code>v0.1.0</code> <a href="https://www.youtube.com/watch?v=ejYcWRERetM&amp;t=2760s">here</a>.</li>
  </ul>
  <item>
    <title>Introduction</title>
    <link>https://schonfinkel.github.io/blog/20240907-experiments_with_erlang_and_nix.html#orgdeb5fa7</link>
    <author>runner@pkrvm7jw40e0xgp (Marcos Benevides)</author>
    <guid isPermaLink="false">7e602f39-1f10-4ac7-9e0f-5b56e3f3ff3c</guid>
    <pubDate>Fri, 24 Jan 2025 21:25:00 +0000</pubDate>

    <description><![CDATA[<p>
    Recently I've been collaborating with friends on <a href="https://github.com/Dr-Nekoma/lyceum">Lyceum</a>, an MMO game with an
    <a href="https://www.erlang.org/">Erlang</a> backend and a <a href="https://ziglang.org/">Zig</a> + <a href="https://www.raylib.com/">Raylib</a> client (as if erlang wasn't a weird enough of
    a choice). Now, this is an unusual combination, but that's the whole reason <a href="https://github.com/Dr-Nekoma">our
    pesky group</a> exists in the first place (if you want to know more check <a href="https://duing.dev/posts/beyondhackers/">my
    friend's Lemos post</a>).
    </p>

    <p>
    There is also a couple of standards we try to follow when doing this project, all
    of the team works with microservices all day in their normal jobs, so whenever
    we want to do something we try follow some simple rules:
    </p>

    <ol class="org-ol">
    <li>Can we develop all of the project parts locally? Preferably with no
    networking as well (besides pulling dependencies).</li>
    <li>Can we do so by leveraging a couple handy tools to their limit?</li>
    </ol>

    <p>
    One can imagine that setting up such a development environment might be
    nightmarish, but thankfully the 21st century brought us some interesting tools
    that make Unix less of a mess to deal with, and yes, I'm talking about <a href="https://nixos.org/">Nix</a>. My
    goal here is to show people what our development experience looks like and maybe
    convince a few souls dealing with more normal tools (<code>brew</code>, <code>asdf</code>, <code>&lt;insert random
    linux package manager&gt;</code>, ...) to at least give Nix a try.
    </p>
    ]]></description>
  </item>
  <item>
    <title>Devenv</title>
    <link>https://schonfinkel.github.io/blog/20240907-experiments_with_erlang_and_nix.html#org9bda4c0</link>
    <author>runner@pkrvm7jw40e0xgp (Marcos Benevides)</author>
    <guid isPermaLink="false">aab28d90-3d14-4095-8ccd-95268984148f</guid>
    <pubDate>Sat, 07 Sep 2024 21:00:00 +0000</pubDate>

    <description><![CDATA[<p>
    We use <a href="https://devenv.sh/">devenv</a> to setup our development shell, think of it as your favorite
    programming language's envinroment and dependency manager (<code>pip</code>, <code>poetry</code>, <code>nvm</code>,
    <code>rvm</code>, ...) but capable of installing anything availiable on <a href="https://search.nixos.org/packages">nixpkgs</a> and
    much more.
    </p>
    <div id="outline-container-ID-8565db0f-88f9-45af-9abc-10119204b46c" class="outline-3">
    <h3 id="ID-8565db0f-88f9-45af-9abc-10119204b46c">A unified development shell for Erlang and Zig</h3>
    <div class="outline-text-3" id="text-org759958c">
    <p>
    No one is expected to have <code>Erlang</code>, <code>Zig</code> and <code>Postgres</code> installed, nor are they
    expected to have any of the environment variables needed for this project to
    work, the development shell already does all of that boring stuff for
    you. Here's a snippet of what it looks like:
    </p>

    <div class="org-src-container">
    <pre class="src src-nix">  # (...)
    devShells =
    let
    linuxPkgs = with pkgs; [
    inotify-tools
    xorg.libX11
    xorg.libXrandr
    xorg.libXinerama
    xorg.libXcursor
    xorg.libXi
    xorg.libXi
    libGL
    ];
    darwinPkgs = with pkgs.darwin.apple_sdk.frameworks; [
    CoreFoundation
    CoreServices
    ];
    in
    {
    # (...)
    # `nix develop`
    default = devenv.lib.mkShell {
    inherit inputs pkgs;
    modules = [
    (
    { pkgs, lib, ... }:
    {
    packages =
    with pkgs;
    [
    just
    raylib
    ]
    ++ lib.optionals stdenv.isLinux (linuxPkgs)
    ++ lib.optionals stdenv.isDarwin darwinPkgs;

    languages.erlang = {
    enable = true;
    package = erlangLatest;
    };

    languages.zig = {
    enable = true;
    package = zigLatest;
    };

    env = mkEnvVars pkgs erlangLatest erlangLibs raylib;

    scripts = {
    build.exec = "just build";
    server.exec = "just server";
    client.exec = "just client";
    db-up.exec = "just db-up";
    db-down.exec = "just db-down";
    db-reset.exec = "just db-reset";
    };

    enterShell = ''
    echo "Starting Development Environment..."
    just deps
    '';

    services.postgres = {
    package = pkgs.postgresql_16.withPackages (p: with p; [ p.periods ]);
    enable = true;
    initialDatabases = [ { name = "mmo"; } ];
    port = 5432;
    listen_addresses = "127.0.0.1";
    initialScript = ''
    CREATE USER admin SUPERUSER;
    ALTER USER admin PASSWORD 'admin';
    GRANT ALL PRIVILEGES ON DATABASE mmo to admin;
    '';
    };
    }
    )
    ];
    };
    };

    # (...)
    </pre>
    </div>

    <p>
    Let's try building the <code>Zig</code> client:
    </p>

    <div class="org-src-container">
    <pre class="src src-shell">  $ just client-build
    $ just client
    </pre>
    </div>



    <div id="orgf14a793" class="figure">
    <p><img src="https://schonfinkel.github.io/blog/../static/img/some_experiments_with_nix_and_erlang/00_lyceum_client.png" alt="00_lyceum_client.png" width="50%" height="50%" align="center" />
    </p>
    <p><span class="figure-number">Figure 1: </span>It just works</p>
    </div>
    </div>
    <div id="outline-container-ID-5bf919ad-05e9-4778-86eb-5d9eeeed11a7" class="outline-4">
    <h4 id="ID-5bf919ad-05e9-4778-86eb-5d9eeeed11a7">Running Postgres</h4>
    <div class="outline-text-4" id="text-orga6c4a69">
    <p>
    As you may have noticed, not only are we installing <code>Erlang</code> and <code>Zig</code>, some
    madlad even put <code>dbeaver</code> there for God knows what reason, but hey, that's the dev
    shell, just do whatever you want. We also have a local postgres setup and the
    workflow mimics what you usually have with <code>docker-compose</code> or <code>podman</code>. By running:
    </p>

    <div class="org-src-container">
    <pre class="src src-shell">  devenv up
    </pre>
    </div>

    <p>
    inside the shell, a local <code>Postgres 16</code> with custom extensions will be
    spinned. The list of services supported by <code>devenv</code> keeps growing and you can
    check them <a href="https://devenv.sh/services/#supported-services">here</a>.
    </p>


    <div id="org244e9cc" class="figure">
    <p><img src="https://schonfinkel.github.io/blog/../static/img/some_experiments_with_nix_and_erlang/01_postgres.png" alt="01_postgres.png" width="50%" height="50%" align="center" />
    </p>
    <p><span class="figure-number">Figure 2: </span>It just works (x2)</p>
    </div>
    </div>
    </div>
    <div id="outline-container-ID-584af4f4-6e5a-4fa1-b5a1-de981cb42a7a" class="outline-4">
    <h4 id="ID-584af4f4-6e5a-4fa1-b5a1-de981cb42a7a">Direnv</h4>
    <div class="outline-text-4" id="text-org7a7737d">
    <p>
    As if thigs weren't awesome enough, I need to talk about <a href="https://direnv.net/">direnv</a>, a simple tool
    that can make wonders (and it comes with nix integrations for free), with a
    single <code>.envrc</code> in your project's repo you can jump inside a certain development
    shell just by <code>cd</code>-ing into the directory. Here's an example of my
    <code>.envrc</code>:
    </p>

    <div class="org-src-container">
    <pre class="src src-nil">use flake . --impure
    </pre>
    </div>

    <p>
    followed by a <code>direnv allow</code> in my shell:
    </p>

    <div class="org-src-container">
    <pre class="src src-shell">  $ direnv allow   
    direnv: loading ~/Code/Personal/lyceum/.envrc                                                                                                                   
    direnv: using flake . --impure
    direnv: nix-direnv: Renewed cache
    Starting Development Environment...
    rebar3 get-deps
    ===&gt; Verifying dependencies...
    rebar3 nix lock
    ===&gt; Verifying dependencies...
    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">(...)</span>
    </pre>
    </div>

    <p>
    That's it. Now every time I <code>cd &lt;lyceum-directory&gt;</code>, I'll immediatly load the
    whole development shell and be ready to work on it. This section is optional but
    it really simplifies my life, as I don't need to remember to activate/deactivate
    an environment.
    </p>
    </div>
    </div>
    </div>
    <div id="outline-container-ID-70f32a8e-d29f-427a-a725-0cffbf5621cd" class="outline-3">
    <h3 id="ID-70f32a8e-d29f-427a-a725-0cffbf5621cd">The CI environment</h3>
    <div class="outline-text-3" id="text-org9d3bbdf">
    <p>
    Since we are already went to the trouble of setting up a whole dev environment
    for Erlang and Zig, we should just make another one for when we need to run
    builds and test suites on CI.
    </p>

    <div class="org-src-container">
    <pre class="src src-nix">   # `nix develop .#ci`
    # reduce the number of packages to the bare minimum needed for CI
    ci = pkgs.mkShell {
    env = mkEnvVars pkgs erlangLatest erlangLibs raylib;
    buildInputs = with pkgs; [
    erlangLatest
    just
    rebar3
    rsync
    zigLatest
    raylib
    ];
    };
    </pre>
    </div>

    <p>
    If you use Github Actions, now you can leverage both the <a href="https://github.com/cachix/install-nix-action">Install Nix</a> and <a href="https://github.com/DeterminateSystems/magic-nix-cache">Magic
    Nix Cache</a> actions.
    </p>
    </div>
    </div>
    <div id="outline-container-ID-a51040ad-8b7d-4e95-b674-b356c63d4204" class="outline-3">
    <h3 id="ID-a51040ad-8b7d-4e95-b674-b356c63d4204">The full devshell</h3>
    <div class="outline-text-3" id="text-orgce28c48">
    <p>
    You can check what the full devshell looks like <a href="https://github.com/Dr-Nekoma/lyceum/blob/master/flake.nix">here</a>.
    </p>
    </div>
    </div>
    ]]></description>
</item>
<item>
  <title>Nix Build</title>
  <link>https://schonfinkel.github.io/blog/20240907-experiments_with_erlang_and_nix.html#org431875c</link>
  <author>runner@pkrvm7jw40e0xgp (Marcos Benevides)</author>
  <guid isPermaLink="false">f685573a-bda5-4523-89ba-ee393d7a7650</guid>
  <pubDate>Sat, 07 Sep 2024 21:00:00 +0000</pubDate>

  <description><![CDATA[<p>
  In the previous section I've showed you our impure environment, there's no way
  (as of now) to make things 100% pure while developing, specially because we need
  to have a postgres service running to debug and test locally. However, things
  change when we talk about releases, we need to find a way to properly build the
  server.
  </p>
  <div id="outline-container-ID-811275b8-8f99-463f-847c-c9feab87ff55" class="outline-3">
  <h3 id="ID-811275b8-8f99-463f-847c-c9feab87ff55">A pure build of the Erlang server</h3>
  <div class="outline-text-3" id="text-org0aab909">
  <p>
  This is the original reason I've decided to write this, it took me some time to
  go through the <a href="https://nixos.org/manual/nixpkgs/stable/#sec-beam">NixOS BEAM manual</a> and I've yet to know how to properly build this
  project with the <a href="https://nixos.org/manual/nixpkgs/stable/#build-tools-rebar3">buildRebar3 Tools</a> (it seems it's used more inside Nixpkgs
  itself than to integrate with Erlang projects). Nevertheless, you can properly
  package this with the abstractions plain Nix already gives you:
  </p>

  <div class="org-src-container">
  <pre class="src src-nix">  # (...)
  # Leverages nix to build the erlang backend release
  # nix build .#server
  server =
  let
  deps = import ./server/rebar-deps.nix {
  inherit (pkgs) fetchHex fetchFromGitHub fetchgit;
  builder = pkgs.beamPackages.buildRebar3;
  };
  in
  pkgs.beamPackages.rebar3Relx {
  pname = erl_app;
  version = app_version;
  root = ./server;
  src = pkgs.lib.cleanSource ./server;
  releaseType = "release";
  profile = "prod";
  include = [
  "rebar.config"
  ];
  beamDeps = builtins.attrValues deps;
  buildPhase = ''
  runHook preBuild
  HOME=. DEBUG=1 rebar3 as prod release --relname server
  runHook postBuild
  '';
  };
  # (...)
  </pre>
  </div>

  <p>
  This is a derivation, a meta-package, a recipe containing every step and every
  dependecy I need to satisfy and properly build our server. Now, as for the
  <code>deps.nix</code> file, it was auto-generated with <a href="https://github.com/erlang-nix/rebar3_nix">rebar3-nix</a>, which itself has a <code>rebar3</code>
  plugin. So everytime someone adds a BEAM dependency in our current flow, we
  automatically generate a nix lockfile to match the rebar3 lockfile as
  well. Here's what we needed to add in our <code>rebar3</code> config to benefit from the Nix
  integration:
  </p>

  <div class="org-src-container">
  <pre class="src src-nil">{plugins, [
  { rebar3_nix, ".*", {git, "https://github.com/erlang-nix/rebar3_nix.git", {tag, "v0.1.1"}}}
  ]}.
  </pre>
  </div>

  <p>
  now let's see if this really works:
  </p>

  <div class="org-src-container">
  <pre class="src src-shell">  $ nix build .#server
  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">(...)</span>
  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">We now have a `result` directory in the project's root...</span>
  $ ls ./result/
  bin  database  erts-13.2.2.10  lib  releases
  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Now try running the server we've just build and...</span>
  $ ./result/bin/server foreground
  Exec: /nix/store/cm6vsbfls41q6s5ms4y2gfnxvmx1qzfq-server/erts-13.2.2.10/bin/erlexec -noinput +Bd -boot /nix/store/cm6vsbfls41q6s5ms4y2gfnxvmx1qzfq-server/releases/0.0.1/start -mode embedded -boot_var SYSTEM_LIB_DIR /nix/store/cm6vsbfls41q6s5ms4y2gfnxvmx1qzfq-server/lib -config /nix/store/cm6vsbfls41q6s5ms4y2gfnxvmx1qzfq-server/releases/0.0.1/sys.config -args_file /nix/store/cm6vsbfls41q6s5ms4y2gfnxvmx1qzfq-server/releases/0.0.1/vm.args -- foreground
  Root: /nix/store/cm6vsbfls41q6s5ms4y2gfnxvmx1qzfq-server
  /nix/store/cm6vsbfls41q6s5ms4y2gfnxvmx1qzfq-server
  Connecting to: <span style="font-style: italic;">"127.0.0.1"</span>
  Connected to <span style="font-style: italic;">"127.0.0.1"</span> with USER = <span style="font-style: italic;">"admin"</span>
  Finding migration scripts... 
  Migration Path: <span style="font-style: italic;">"/nix/store/cm6vsbfls41q6s5ms4y2gfnxvmx1qzfq-server/database/migrations"</span>
  Running DB migrations.
  Migrations completed successfully.
  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">(...) it works</span>
  </pre>
  </div>
  </div>
  </div>
  <div id="outline-container-ID-cd24d037-768a-4cea-8dc6-6cd0e2b93db2" class="outline-3">
  <h3 id="ID-cd24d037-768a-4cea-8dc6-6cd0e2b93db2">A pure build of the Zig client</h3>
  <div class="outline-text-3" id="text-orgc456f79">
  <div class="org-src-container">
  <pre class="src src-nix">  # (...)
  # nix build .#client
  client = pkgs.stdenv.mkDerivation {
  pname = zig_app;
  version = app_version;
  src = pkgs.lib.cleanSource ./client;

  zigBuildFlags = [
  "-fsys=raylib"
  "--release=fast"
  "-Dassets=${builtins.toString ./client}/assets"
  ];

  nativeBuildInputs = [
  zigLatest.hook
  pkgs.makeWrapper
  ];

  buildInputs =
  with pkgs; [ raylib zigLatest erlangLatest ]
  ++ lib.optionals stdenv.isLinux (linuxPkgs)
  ++ lib.optionals stdenv.isDarwin darwinPkgs;

  postPatch = ''
  ln -s ${pkgs.callPackage ./client/zon-deps.nix { }} $ZIG_GLOBAL_CACHE_DIR/p
  '';

  postInstall = ''
  wrapProgram "$out/bin/${zig_app}" --prefix LD_LIBRARY_PATH ":" "${linuxLibs}"
  '';
  };

  # (...)
  </pre>
  </div>
  </div>
  </div>
  ]]></description>
</item>
<item>
  <title>Containers</title>
  <link>https://schonfinkel.github.io/blog/20240907-experiments_with_erlang_and_nix.html#org76d4ae8</link>
  <author>runner@pkrvm7jw40e0xgp (Marcos Benevides)</author>
  <guid isPermaLink="false">d580359f-8331-45c2-bf07-aa506489fbcd</guid>
  <pubDate>Sat, 07 Sep 2024 21:00:00 +0000</pubDate>

  <description><![CDATA[<p>
  There is a treasure trove of examples in <a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/build-support/docker/examples.nix#L218">Nixpkgs</a>, I've decided to go with the
  <b><b>simplest</b></b> one. This what a container for the backend looks like in Nix:
  </p>

  <div class="org-src-container">
  <pre class="src src-nix">  # nix build .#dockerImage
  dockerImage = pkgs.dockerTools.buildLayeredImage {
  name = erl_app;
  tag = "latest";
  created = "now";
  # This will copy the compiled erlang release to the image
  contents = [
  server
  pkgs.coreutils
  pkgs.gawk
  pkgs.gnugrep
  pkgs.openssl
  ];
  config = {
  Volumes = {
  "/opt/${erl_app}/etc" = {};
  "/opt/${erl_app}/data" = {};
  "/opt/${erl_app}/log" = {};
  };
  WorkingDir = "/opt/${erl_app}";
  Cmd = [
  "${server}/bin/${erl_app}"
  "foreground"
  ];
  Env = [
  "ERL_DIST_PORT=8080"
  "ERL_AFLAGS=\"-kernel shell_history enabled\""
  "NODE_NAME=${erl_app}"
  ];
  ExposedPorts = {
  "4369/tcp" = {};
  "4369/ucp" = {};
  "8080/tcp" = {};
  "8080/udp" = {};
  };
  };
  };

  </pre>
  </div>

  <p>
  It doesn't really look like most Dockerfiles you see around the net. Notice that
  I'm using the <code>server</code> derivation from the previous step, the hard work required
  to make it work the first time is immediatly rewarded because now we can keep
  composing the previous solutions into more complex flows. To test this, let's
  build the image:
  </p>

  <div class="org-src-container">
  <pre class="src src-shell">  $ nix build .#dockerImage
  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Now load the build image in docker (or podman)</span>
  $ docker load &lt; ./result
  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Make sure you have `devenv up` running</span>
  $ docker container run --network=host --rm lyceum:latest
  Exec: /nix/store/vwnrgsah54qf9ca0ax921061b6sm1km9-server/erts-13.2.2.10/bin/erlexec -noinput +Bd -boot /nix/store/vwnrgsah54qf9ca0ax921061b6sm1km9-server/releases/0.0.1/start -mode embedded -boot_var SYSTEM_LIB_DIR /nix/store/vwnrgsah54qf9ca0ax921061b6sm1km9-server/lib -config /nix/store/vwnrgsah54qf9ca0ax921061b6sm1km9-server/releases/0.0.1/sys.config -args_file /nix/store/vwnrgsah54qf9ca0ax921061b6sm1km9-server/releases/0.0.1/vm.args -- foreground
  Root: /nix/store/vwnrgsah54qf9ca0ax921061b6sm1km9-server
  /nix/store/vwnrgsah54qf9ca0ax921061b6sm1km9-server
  server[1] Starting up
  Connecting to: <span style="font-style: italic;">"127.0.0.1"</span>
  Connected to <span style="font-style: italic;">"127.0.0.1"</span> with USER = <span style="font-style: italic;">"admin"</span>
  Finding migration scripts... 
  Migration Path: <span style="font-style: italic;">"/nix/store/vwnrgsah54qf9ca0ax921061b6sm1km9-server/database/migrations"</span>
  Running DB migrations.
  Migrations completed successfully.
  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">(...)</span>
  </pre>
  </div>
  ]]></description>
</item>
<item>
  <title>Conclusion</title>
  <link>https://schonfinkel.github.io/blog/20240907-experiments_with_erlang_and_nix.html#org05f8b7a</link>
  <author>runner@pkrvm7jw40e0xgp (Marcos Benevides)</author>
  <guid isPermaLink="false">3b940c14-5918-4c48-868c-447d7f19d69b</guid>
  <pubDate>Sat, 07 Sep 2024 21:00:00 +0000</pubDate>

  <description><![CDATA[<p>
  As I wanted to show here, we've used Nix all the way from defining a common
  development environment for the developers, reused some of the stuff in CI, to
  later repurpose some of the flows for pure builds, that later got shoved into
  our containers, all by leveraging the <b><b>same tool</b></b>. I wish modern devops was more
  about that, but it seems it'll take time for people to realize that
  <b><b>immutability</b></b>, <b><b>composition</b></b> and <b><b>functional programming</b></b> can go hand in hand
  and give us a better experience than one can find in most other solutions (built
  by trillion dollar companies who want you to manage infra with YAML). Luckilly,
  Nix is <a href="https://www.youtube.com/watch?v=FJVFXsNzYZQ">gaining some traction</a> and more people are talking about it.
  </p>

  <p>
  I've been using it for the past 6 years in my workstations and don't regret
  doing so, its a tool worth learning (and there's still so much to learn about
  it), it makes my life dealing with Unix systems less painfull.
  </p>
  ]]></description>
</item>
</channel>
</rss>
