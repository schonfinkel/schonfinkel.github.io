#+TITLE: The road to Emacs maximalism
#+SUBTITLE: Building an Emacs Utopia with hot glue, duct tape and Nix
#+AUTHOR: Marcos Benevides
#+DATE: <2025-01-01 Wed>

#+begin_quote
Iâ€™ve stumbled across a method of composing programs that excites me very
much. In fact, my enthusiasm is so great that I must warn the reader to discount
much of what I shall say as the ravings of a fanatic who thinks he has just seen
a great light. [cite:@knuth1984literate p.1]
#+end_quote

* Introduction

A couple years ago I've started watching [[https://github.com/sponsors/daviwil][David Wilson's]] channel (also know as
[[https://www.youtube.com/c/SystemCrafters][SystemCrafters]]), originally his channel focused heavilly on[[https://fsharp.org/][ F#]] (and that's how
I've found him), but eventually he started posting more and "GNU slash Emacs"
content. I lost interest on the channel at the time, while he did indeed
showcase a level of productivity that was way above what I had, I felt like it
could be easily emulated with a combination of Neovim and some other Linux
tools.

Everything changed once I saw his [[https://www.youtube.com/watch?v=AyhPmypHDEw][presentation]] about of [[https://www.orgroam.com/][org-roam]], my brain got
hijacked by the idea of testing Emacs. I had already heard about [[https://orgmode.org/][orgmode]] before,
but it was never on my radar since it always felt like some [[https://xkcd.com/378/]["Emacs weirdo"]]
cool-aid.

the reason being that I've always had the
need for some tool to help me organize my notes (specially during college where
most of my annotations got lost). To fill this gap, such a tool would need to
have the following properties:

1. Document everything that I've done.
2. Register and link everything that I've read, preferably by integrating:
   + Text
   + Math
   + Code
   + Citations
3. Manage and track figures, while maintaing referential integrity.
4. Be free (as in freedom) or open source.

Obsidian tickles most of these (if you consider its plugins), but the [[https://obsidian.md/license][license]] is
a little bit worrying and you can bet they will pull an [[https://github.com/Kong/insomnia/issues/6577][insomnia]] in the future.

    #+begin_quote
    (...) trivial usage of *Org-mode* is nothing more than text editing, from which
    point the user can start to add special plain text *Org-mode* elements to the
    document. *Org-mode* is therefore easy to adopt and aims to be a general solution
    for authoring projects with mixed computational and natural languages. It
    supports multiple programming languages, export targets, and work flows.
    [cite:@schulte2012multi p.2]
    #+end_quote

an extensible framework for your entire digital workflow.

Org is a major mode in Emacs, it is also a markup language (similar to
~markdown~ or ~reStructuredText~), but much more powerful.

The way Org-mode could combine writing, planning, and programming into one
cohesive system immediately piqued my curiosity. Watching him effortlessly
schedule tasks, link notes, and build agendas convinced me to give Emacs a
serious try.

** Literate Programming


* Orgmode

#+begin_quote
*Org-mode* extends *Emacs* with a simple and powerful markup language that turns it
into a language for creating, parsing, and interacting with
hierarchically-organized text documents. Its rich feature set includes text
structuring, project management, and a publishing system that can export to a
variety of formats. Source code and data are located in active blocks, distinct
from text sections, where "active" here means that code and data blocks can be
evaluated to return their contents or their computational results. The results
of code block evaluation can be written to a named data block in the document,
where it can be referred to by other code blocks, any one of which can be
written in a different computing language. In this way, an *Org-mode* buffer
becomes a place where different computer languages communicate with one
another. Like *Emacs*, *Org-mode* is extensible: support for new languages can be
added by the user in a modular fashion through the definition of a small number
of *Emacs Lisp* functions.
[cite:@schulte2012multi p.7]
#+end_quote

** Roam

** Stealing the Graph

I've copid a lot from Hugo Cisnero's [[https://hugocisneros.com/blog/my-org-roam-notes-workflow/][awesome blogpost]] from a couple years ago
and he really like how he sets things up. The python 

** Diagrams as Code

** Arbitrary Code Execution and Generation

#+begin_quote
Borrowing terms from the literate programming literature, ~Org-mode~ supports both
*weaving* - the exportation of a mixed code/prose document to a format suitable
for reading by a human - and *tangling* - the exportation of a mixed code/prose
document to a pure code file suitable for execution by a
computer. [cite:@schulte2012multi p.12]
#+end_quote

** Exports
You take an org file and [[https://orgmode.org/manual/Publishing-options.html][export it]] to different formats like: ~html~ (that's how
this blog is made), ~LaTeX~, ~markdown~, etc.

* The Implementation
** Nix

Knuth has a point about some of the portability issues on his "Literate
Programming" paper, even though the markup language (~WEB~) was portable to
different systems, the same could not be said of the ~PASCAL~ compilers that were
generating the code:

#+begin_quote
Furthermore, many of the world's PASCAL compilers are incredibly
bizarre. Therefore it is quite naive to believe that a single program TANGLE.PAS
could actually work on very many different machines, or even that one single
source file TANGLE.WEB could be adequate; some system-dependent changes are
inevitable. [cite:@knuth1984literate p.10]
#+end_quote

Technically, any modern literate programming environment (heck any programming
environmnt in general) is going to suffer from similar issues (instead of
multiple compilers we have multiple package managers and DLL hell). If you use a
~python~ notebook and never bothered to pin your dependencies, or worse, if no one
knows which version of the interpreter was used initially, then there is a
pretty good chance the project will be unrunable in a couple months.

The idea is to have a custom emacs in CI with all the plugins we need to build
this the blog and org roam notes:

#+begin_src nix
  # (...)
  customEmacs = (pkgs.emacsPackagesFor pkgs.emacs-nox).emacsWithPackages (
      epkgs:
      with epkgs.melpaPackages;
      [
        citeproc
      ]
      ++ (with epkgs.elpaPackages; [
        org
        org-roam
        org-roam-ui
      ])
  );
  # (...)
#+end_src

but only use the custom emacs build on the CI shell, the default (impure)
development shell is still going to pull your local Emacs:

#+begin_src nix
  {
    # `nix develop .#ci`
    # Reduce the number of packages to the bare minimum needed for CI,
    # by removing LaTeX and not using my own Emacs configuration, but
    # a custom package with just enough tools for org-publish.
    ci = pkgs.mkShell {
      ENVIRONMENT = "prod";
      OUT_URL = "https://schonfinkel.github.io/";
      DOTNET_ROOT = "${dotnet}";
      DOTNET_CLI_TELEMETRY_OPTOUT = "1";
      LANG = "en_US.UTF-8";
      buildInputs = [ dotnet customEmacs ] ++ tooling;
    };

    # `nix develop --impure`
    # This is the development shell, meant to be used as an impure
    # shell, so no custom Emacs here, just use your global package
    # switch back to the CI shell for builds.
    default = devenv.lib.mkShell {
      inherit inputs pkgs;
      modules = [
        (
          { pkgs, lib, ... }:
          {
            packages = [ dotnet texenv ] ++ tooling;

            env = {
              ENVIRONMENT = "dev";
              DOTNET_ROOT = "${dotnet}";
              DOTNET_CLI_TELEMETRY_OPTOUT = "1";
              LANG = "en_US.UTF-8";
            };

            scripts = {
              build.exec = "just build";
              graph.exec = "just graph";
              clean.exec = "just clean";
            };

            enterShell = ''
              echo "Starting environment..."
            '';
          }
        )
      ];
  };
#+end_src


** Continous Integration

Again, I benefit from a somewhat easy to setup CI pipeline thanks to
[[https://github.com/cachix/install-nix-action][install-nix]], it's a copy of what I already do locally. And you can also benefit
from faster builds with the [[https://github.com/DeterminateSystems/magic-nix-cache][magic-nix-cache]].

#+begin_src yaml
      - name: Install Nix
        uses: cachix/install-nix-action@v27

      - name: Install Nix Cache
        uses: DeterminateSystems/magic-nix-cache-action@main

      - name: Build website
        run: |
          mkdir -p "$HOME/.emacs.d/"
          touch "$HOME/.emacs.d/.org-id-locations"
          nix develop .#ci -c just build

      - name: Deploy
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./public
#+end_src



** What is Still Missing

- Anki-Like Flashcards: With either [[https://orgmode.org/worg/org-contrib/org-drill.html\\][org-drill]] or [[https://www.leonrische.me/fc/index.html][org-fc]].

- Integration with [[https://github.com/jkitchin/org-ref][org-ref]]: ~org-ref~ offers a suite of tools that would make
  keeping track of references easier as the number of notes and posts increases.

- Remove some of the Polyglot Templating: Although the polyglot usage of
  different programming languages here was a good way to show some of orgmode's
  export features, I know my usage of ~F#~ is unecessary, I could have done the
  same in pure ~elisp~, but I still suck at it.

* Notable Mentions

** Hugo

This blog was originally fully integrated with[[https://gohugo.io/][ hugo]] and [[https://ox-hugo.scripter.co/][ox-hugo]] (first stolen
from [[https://github.com/ratsclub][my close friend]]), but eventually I've started facing issues since the way I
organize files (one per post) is not recommended by ox-hugo. Since my

** Quartz

Similar to ~hugo~, although [[https://quartz.jzhao.xyz/][Quartz]] is also built to support [[https://obsidian.md/][Obsidian]]-like notes.

** Emanote

Before doing the full refactor and moving it back to a pure [[https://orgmode.org/manual/Publishing.html][org-publish]]
workflow, I found out about [[https://emanote.srid.ca/][emanote]]. It is similar to Quartz, but it feels
overall better since the license is ~AGPL v3~. It's also built atop of Markdown,
but there are [[https://github.com/srid/emanote/blob/master/docs/guide/orgmode.org][steps]] on how to configure this to use ~org~. May be a good choice
for people already familiar with Haskell and Nix.

* References
#+print_bibliography: 
