<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
     xmlns:georss="http://www.georss.org/georss"
     xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"
     xmlns:media="http://search.yahoo.com/mrss/"><channel>
  <title>The road to Emacs maximalism</title>
  <atom:link href="https://schonfinkel.github.io/blog/20241230-the_road_to_emacs_maximalism.xml" rel="self" type="application/rss+xml" />
  <link>https://schonfinkel.github.io/blog</link>
  <description><![CDATA[]]></description>
  <language>en</language>
  <pubDate>Fri, 03 Oct 2025 18:56:54 +0000</pubDate>
  <lastBuildDate>Fri, 03 Oct 2025 18:56:54 +0000</lastBuildDate>
  <generator>Emacs 30.1 Org-mode 9.7.30</generator>
  <webMaster>runner@runnervm3ublj (Marcos Benevides)</webMaster>
  <image>
    <url>https://orgmode.org/img/org-mode-unicorn-logo.png</url>
    <title>The road to Emacs maximalism</title>
    <link>https://schonfinkel.github.io/blog</link>
  </image>

  <blockquote>
    <p>
      I’ve stumbled across a method of composing programs that excites me very
      much. In fact, my enthusiasm is so great that I must warn the reader to discount
      much of what I shall say as the ravings of a fanatic who thinks he has just seen
      a great light. (<a href="#citeproc_bib_item_1">Knuth 1984, 1</a>)
    </p>
  </blockquote>
  <item>
    <title>Introduction</title>
    <link>https://schonfinkel.github.io/blog/20241230-the_road_to_emacs_maximalism.html#org0c4b41d</link>
    <author>runner@runnervm3ublj (Marcos Benevides)</author>
    <guid isPermaLink="false">1294efc9-91ca-464f-9f50-f16d1d66bff6</guid>
    <pubDate>Mon, 30 Dec 2024 21:00:00 +0000</pubDate>

    <description><![CDATA[<p>
    A couple years ago I've started watching <a href="https://github.com/sponsors/daviwil">David Wilson's</a> channel (also know as
    <a href="https://www.youtube.com/c/SystemCrafters">SystemCrafters</a>), originally his channel focused heavilly on<a href="https://fsharp.org/"> F#</a> (and that's how I
    found him), but eventually he started posting more and "GNU slash Emacs"
    content. I lost interest on the channel at the time, while he did indeed
    showcase a level of productivity that was way above what I had, I felt like it
    could be easily emulated with a combination of <code>Neovim</code> and some other Linux
    tools.
    </p>

    <p>
    Everything changed once I saw his <a href="https://www.youtube.com/watch?v=AyhPmypHDEw">presentation</a> about <a href="https://www.orgroam.com/">org-roam</a>, my brain got
    hijacked by the idea of testing <code>Emacs</code>. I had previously heard about <a href="https://orgmode.org/">orgmode</a>
    before, but it was never on my radar since it felt like some <a href="https://xkcd.com/378/">"Emacs weirdo"</a>
    cool-aid. What got me impressed was that I always needed some tool to help me
    organize my notes (specially during college where most of my annotations got
    lost). To fill this gap, such a tool would need to have the following
    properties:
    </p>

    <ol class="org-ol">
    <li>Document everything that I've done.</li>
    <li>Register and link everything that I've read, preferably by integrating:
    <ul class="org-ul">
    <li>Text</li>
    <li>Math</li>
    <li>Code</li>
    <li>Citations</li>
    </ul></li>
    <li>Manage and track figures, while maintaing referential integrity.</li>
    <li>Be free (as in freedom) or open source.</li>
    </ol>

    <p>
    Obsidian tickles most of these (if you consider its plugins), but the <a href="https://obsidian.md/license">license</a> is
    a little bit worrying and you can bet they will pull an <a href="https://github.com/Kong/insomnia/issues/6577">insomnia</a> in the
    future. <a href="https://github.com/logseq/logseq">Logseq</a> is a much better alternative in this regard, plus you have the
    option of using something much better than <code>markdown</code> or <code>reStructuredText</code>, and that
    is <code>org</code>.
    </p>

    <blockquote>
    <p>
    (...) trivial usage of <b>Org-mode</b> is nothing more than text editing, from which
    point the user can start to add special plain text <b>Org-mode</b> elements to the
    document. <b>Org-mode</b> is therefore easy to adopt and aims to be a general solution
    for authoring projects with mixed computational and natural languages. It
    supports multiple programming languages, export targets, and work flows.
    (<a href="#citeproc_bib_item_2">Schulte et al. 2012, 2</a>)
    </p>
    </blockquote>

    <p>
    Org is a major<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Modes.html"> mode</a> in Emacs, it is also a powerful markup language and I would
    argue a better tool than any of the current alternatives. If properly
    configured, <code>orgmode</code> can combine writing, planning, scheduling, linking and
    programming into a cohesive workflow.
    </p>

    <blockquote>
    <p>
    <b>Org-mode</b> extends <b>Emacs</b> with a simple and powerful markup language that turns it
    into a language for creating, parsing, and interacting with
    hierarchically-organized text documents. Its rich feature set includes text
    structuring, project management, and a publishing system that can export to a
    variety of formats. Source code and data are located in active blocks, distinct
    from text sections, where "active" here means that code and data blocks can be
    evaluated to return their contents or their computational results. The results
    of code block evaluation can be written to a named data block in the document,
    where it can be referred to by other code blocks, any one of which can be
    written in a different computing language. In this way, an <b>Org-mode</b> buffer
    becomes a place where different computer languages communicate with one
    another. Like <b>Emacs</b>, <b>Org-mode</b> is extensible: support for new languages can be
    added by the user in a modular fashion through the definition of a small number
    of <b>Emacs Lisp</b> functions.
    (<a href="#citeproc_bib_item_2">Schulte et al. 2012, 7</a>)
    </p>
    </blockquote>
    <div id="outline-container-ID-7a2263c7-fc32-4e2e-b5d3-bb97987b9cd7" class="outline-3">
    <h3 id="ID-7a2263c7-fc32-4e2e-b5d3-bb97987b9cd7">Literate Programming</h3>
    <div class="outline-text-3" id="text-org32c0deb">
    <blockquote>
    <p>
    I believe that the time is ripe for significantly better documentation of
    programs, and that we can best achieve this by considering programs to be works
    of literature. Hence, my title: "Literate Programming."
    (<a href="#citeproc_bib_item_1">Knuth 1984, 1</a>)
    </p>
    </blockquote>

    <p>
    I must admit that, even though the idea itself seems interesting, time has
    proven that "literate programming" the way Knuth is suggesting is impractical,
    but lets forgive him, it was 1984. When it comes to documentation, I would
    rather deal with a good type system (like the ones inpired by the ML-family of
    languages) and/or have proper documentation tooling (<a href="https://hexdocs.pm/elixir/docs-tests-and-with.html#doctests">hexdocs</a> is the gold
    standard as far as I could experience).
    </p>

    <p>
    I'm emphasizing this because <a href="https://orgmode.org/worg/org-contrib/babel/intro.html">org-babel</a> (which is part of <code>org-mode</code>) is a
    practical tool to make <code>Emacs</code> a literate programming environment.
    </p>

    <blockquote>
    <p>
    Borrowing terms from the literate programming literature, <code>Org-mode</code> supports both
    <b>weaving</b> - the exportation of a mixed code/prose document to a format suitable
    for reading by a human - and <b>tangling</b> - the exportation of a mixed code/prose
    document to a pure code file suitable for execution by a
    computer. (<a href="#citeproc_bib_item_2">Schulte et al. 2012, 12</a>)
    </p>
    </blockquote>
    </div>
    </div>
    ]]></description>
</item>
<item>
  <title>Orgmode</title>
  <link>https://schonfinkel.github.io/blog/20241230-the_road_to_emacs_maximalism.html#org530f65b</link>
  <author>runner@runnervm3ublj (Marcos Benevides)</author>
  <guid isPermaLink="false">cd679f88-fedc-4132-95d7-b746c36322da</guid>
  <pubDate>Mon, 30 Dec 2024 21:00:00 +0000</pubDate>

  <description><![CDATA[<div id="outline-container-ID-aaefc243-0470-4229-92d5-7ecd1b5bdeaf" class="outline-3">
  <h3 id="ID-aaefc243-0470-4229-92d5-7ecd1b5bdeaf">Arbitrary Code Execution and Generation</h3>
  <div class="outline-text-3" id="text-org6e0dcc3">
  <p>
  Here's what my <code>blog.org</code> file looks like:
  </p>

  <div class="org-src-container">
  <pre class="src src-org">    Here you'll find my latest content, projects, tutorials and ramblings.

  <span style="font-weight: bold; font-style: italic;">    #+header: :exports results</span>
  <span style="font-weight: bold; font-style: italic;">    #+header: :results html</span>
  <span style="font-weight: bold; font-style: italic;">    #+NAME: export-posts</span>
  <span style="font-weight: bold; font-style: italic;">    #+BEGIN_SRC shell</span>
  dotnet fsi posts.fsx
  <span style="font-weight: bold; font-style: italic;">    #+END_SRC</span>
  </pre>
  </div>

  <p>
  it's a single text line that also calls a shell command, <code>dotnet fsi posts.fsx</code>,
  <code>posts.fsx</code> is an <code>F#</code> file that generates html content as a huge string:
  </p>

  <div class="org-src-container">
  <pre class="src src-shell">  $ dotnet fsi posts.fsx 

  &lt;div <span style="font-weight: bold; font-style: italic;">class</span>=<span style="font-style: italic;">"stub"</span>&gt;
  &lt;h2&gt;
  &lt;a <span style="font-weight: bold; font-style: italic;">href</span>=<span style="font-style: italic;">"./blog/20241231-the_road_to_emacs_maximalism.html"</span>&gt; The road to Emacs maximalism &lt;/a&gt;
  &lt;/h2&gt;
  &lt;small&gt;2024-12-31&lt;/small&gt;
  &lt;/div&gt;
  

  &lt;div <span style="font-weight: bold; font-style: italic;">class</span>=<span style="font-style: italic;">"stub"</span>&gt;
  &lt;h2&gt;
  &lt;a <span style="font-weight: bold; font-style: italic;">href</span>=<span style="font-style: italic;">"./blog/20240916-you_have_10_seconds_to_nixify_your_dotnet_project.html"</span>&gt; You have 10 seconds to nixify your dotnet project &lt;/a&gt;
  &lt;/h2&gt;
  &lt;small&gt;2024-09-16&lt;/small&gt;
  &lt;/div&gt;

  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">And so on...</span>
  </pre>
  </div>

  <p>
  This could have been done in any language really, but I felt more comfortable
  quickly pulling this in <code>F#</code>, the <code>#+header: :results html</code> makes sure this will be
  correctly exported to <code>html</code> once we run the <code>publish.el</code> file (either locally on in
  CI). 
  </p>
  </div>
  </div>
  <div id="outline-container-ID-641485b8-6dd0-4909-b8e1-8d9744bb0338" class="outline-3">
  <h3 id="ID-641485b8-6dd0-4909-b8e1-8d9744bb0338">Roam</h3>
  <div class="outline-text-3" id="text-org3742380">
  <p>
  Similar to the previous section, my <a href="https://schonfinkel.github.io/notes.html">notes</a> are also generated via some hacky <code>F#</code>
  script:
  </p>

  <div class="org-src-container">
  <pre class="src src-org">  This is the place where I dump my <span style="text-decoration: underline;"><a href="https://www.orgroam.com/">Org ROAM</a></span> notes.

  <span style="font-weight: bold; font-style: italic;">  #+INCLUDE: ./static/html/graph.html export html</span>

  <span style="font-weight: bold; font-style: italic;">  #+header: :exports results</span>
  <span style="font-weight: bold; font-style: italic;">  #+header: :results html</span>
  <span style="font-weight: bold; font-style: italic;">  #+NAME: export-posts</span>
  <span style="font-weight: bold; font-style: italic;">  #+BEGIN_SRC shell</span>
  dotnet fsi notes.fsx
  <span style="font-weight: bold; font-style: italic;">  #+END_SRC</span>
  </pre>
  </div>

  <p>
  The difference being that there is an extra <code>#+INCLUDE:</code> directive importing
  actual html code. That's where the <code>d3.js</code> graph setup is.
  </p>
  </div>
  <div id="outline-container-ID-1653090e-9f07-47f3-bc17-dfee925ecba7" class="outline-4">
  <h4 id="ID-1653090e-9f07-47f3-bc17-dfee925ecba7">Stealing the Graph</h4>
  <div class="outline-text-4" id="text-org011ac8b">

  <div id="org6e830df" class="figure">
  <p><img src="https://schonfinkel.github.io/blog/../static/img/the_road_to_emacs_maximalism/notes.png" alt="notes.png" width="70%" height="70%" align="center" />
  </p>
  <p><span class="figure-number">Figure 1: </span>My crappy graph</p>
  </div>

  <p>
  I've blatantly copied from Hugo Cisnero's <a href="https://hugocisneros.com/blog/my-org-roam-notes-workflow/">awesome blogpost</a> a couple years ago
  and I really like how he generated a graph out of the <code>sqlite</code> db already used by
  <code>org-roam</code>. Some minimal changes were required to render my graph, it is sparser
  than his, so forcing a minimum number of communites doesn't look that good (a
  quick hack is taking the number of <a href="https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.components.weakly_connected_components.html#networkx.algorithms.components.weakly_connected_components">weakly connected components</a>). To build the
  graph one just needs to run:
  </p>

  <div class="org-src-container">
  <pre class="src src-shell">  just graph
  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">or</span>
  graph
  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">inside the Nix shell</span>
  </pre>
  </div>

  <p>
  Note that this used to be an <a href="https://github.com/org-roam/org-roam-ui/discussions/109#discussioncomment-8272050">feature request</a> on Github, until someone created a
  <a href="https://github.com/marketplace/actions/publish-org-roam-ui">publish-org-roam-ui</a> github action. Maybe that's what most people need, but it
  won't work for me, at least in this current iteration of the blog.
  </p>
  </div>
  </div>
  </div>
  <div id="outline-container-ID-4f02e18f-3564-455e-b5f9-6400892a6f54" class="outline-3">
  <h3 id="ID-4f02e18f-3564-455e-b5f9-6400892a6f54">Diagrams as Code</h3>
  <div class="outline-text-3" id="text-orgb6ff040">
  <p>
  For my current needs <code>graphviz</code> is enough, but I can keep adding similar
  tools later:
  </p>

  <div class="org-src-container">
  <pre class="src src-dot" id="org18f0b32">  digraph {
  a -&gt; b;
  b -&gt; c;
  c -&gt; a;
  }
  </pre>
  </div>


  <div id="org061f1c7" class="figure">
  <p><img src="https://schonfinkel.github.io/blog/../static/img/the_road_to_emacs_maximalism/graphviz_example.png" alt="graphviz_example.png" />
  </p>
  </div>
  </div>
  </div>
  <div id="outline-container-ID-c8f3907d-9bcf-4b87-8e3f-2bacd0f4d2fa" class="outline-3">
  <h3 id="ID-c8f3907d-9bcf-4b87-8e3f-2bacd0f4d2fa">Exports</h3>
  <div class="outline-text-3" id="text-orgb4a3104">
  <p>
  You take an org file and <a href="https://orgmode.org/manual/Publishing-options.html">export it</a> to different formats like: <code>html</code> (that's how
  this blog is made), <code>LaTeX</code>, <code>markdown</code>, etc. Currently I only care about the <code>html</code>
  export and you can find the <code>publish.el</code> file <a href="https://github.com/schonfinkel/schonfinkel.github.io/blob/master/publish.el">here.</a>
  </p>
  </div>
  </div>
  ]]></description>
</item>
<item>
  <title>The Infrastructure</title>
  <link>https://schonfinkel.github.io/blog/20241230-the_road_to_emacs_maximalism.html#org9d4ad39</link>
  <author>runner@runnervm3ublj (Marcos Benevides)</author>
  <guid isPermaLink="false">8d9ed80b-0862-41e7-abd5-8dce2a0bf64b</guid>
  <pubDate>Mon, 30 Dec 2024 21:00:00 +0000</pubDate>

  <description><![CDATA[<p>
  Knuth has a point about some of the portability issues on his "Literate
  Programming" paper, even though the markup language (<code>WEB</code>) was portable to
  different systems, the same could not be said of the <code>PASCAL</code> compilers that were
  generating the code:
  </p>

  <blockquote>
  <p>
  Furthermore, many of the world's PASCAL compilers are incredibly
  bizarre. Therefore it is quite naive to believe that a single program TANGLE.PAS
  could actually work on very many different machines, or even that one single
  source file TANGLE.WEB could be adequate; some system-dependent changes are
  inevitable. (<a href="#citeproc_bib_item_1">Knuth 1984, 10</a>)
  </p>
  </blockquote>

  <p>
  Technically, any modern literate programming environment (heck any programming
  environment in general) is going to suffer from similar issues (instead of
  multiple compilers we have multiple package managers and DLL hell). If you use a
  <code>python</code> notebook and never bothered to pin your dependencies, or worse, if no one
  knows which version of the interpreter was used initially, then give it a couple
  months and there's a pretty good chance it will never run.
  </p>
  <div id="outline-container-ID-062b018a-f9e1-4b6b-a26a-fc2cc2ac8ac3" class="outline-3">
  <h3 id="ID-062b018a-f9e1-4b6b-a26a-fc2cc2ac8ac3">Nix</h3>
  <div class="outline-text-3" id="text-org874b2cb">
  <p>
  To make this less likelly to happen, my development environment heavilly relies
  on <a href="https://nixos.org/">Nix</a> and <a href="https://devenv.sh/">devenv</a>. Everything is set in a single <a href="https://github.com/schonfinkel/schonfinkel.github.io/blob/master/flake.nix">flake.nix</a> file, a <code>LaTeX</code>
  environment with a couple dependencis, some <code>.NET</code> and <code>Python</code> libs, <code>sqlite</code>, <a href="https://github.com/casey/just">just</a>
  and even a custom <code>Emacs</code> to be used in CI, this might seem cursed but it's really
  easy to pull this off on Nix:
  </p>

  <div class="org-src-container">
  <pre class="src src-nix">  # (...)
  customEmacs = (pkgs.emacsPackagesFor pkgs.emacs-nox).emacsWithPackages (
  epkgs:
  with epkgs.melpaPackages;
  [
  citeproc
  htmlize
  ox-rss
  ]
  ++ (with epkgs.elpaPackages; [
  org
  org-roam
  org-roam-ui
  ])
  );
  # (...)
  </pre>
  </div>

  <p>
  this is only used the CI shell, where we require <code>Emacs</code> with a minimum set of
  plugins to publish the website, the default (impure) development shell is still
  going to pull your local Emacs:
  </p>

  <div class="org-src-container">
  <pre class="src src-nix">  {
  # `nix develop .#ci`
  # Reduce the number of packages to the bare minimum needed for CI,
  # by removing LaTeX and not using my own Emacs configuration, but
  # a custom package with just enough tools for org-publish.
  ci = pkgs.mkShell {
  ENVIRONMENT = "prod";
  OUT_URL = "https://schonfinkel.github.io/";
  DOTNET_ROOT = "${dotnet}";
  DOTNET_CLI_TELEMETRY_OPTOUT = "1";
  LANG = "en_US.UTF-8";
  buildInputs = [ dotnet customEmacs ] ++ tooling;
  };

  # `nix develop --impure`
  # This is the development shell, meant to be used as an impure
  # shell, so no custom Emacs here, just use your global package
  # switch back to the CI shell for builds.
  default = devenv.lib.mkShell {
  inherit inputs pkgs;
  modules = [
  (
  { pkgs, lib, ... }:
  {
  packages = [ dotnet texenv ] ++ tooling;

  env = {
  ENVIRONMENT = "dev";
  DOTNET_ROOT = "${dotnet}";
  DOTNET_CLI_TELEMETRY_OPTOUT = "1";
  LANG = "en_US.UTF-8";
  };

  scripts = {
  build.exec = "just build";
  graph.exec = "just graph";
  clean.exec = "just clean";
  };

  enterShell = ''
  echo "Starting environment..."
  '';
  }
  )
  ];
  };
  </pre>
  </div>

  <p>
  the full setup can be found in the main <a href="https://github.com/schonfinkel/schonfinkel.github.io/blob/master/flake.nix">repo</a>.
  </p>
  </div>
  </div>
  <div id="outline-container-ID-2a785563-245e-4952-a45a-89c1d0631af7" class="outline-3">
  <h3 id="ID-2a785563-245e-4952-a45a-89c1d0631af7">Continous Integration</h3>
  <div class="outline-text-3" id="text-orgdddb1e4">
  <p>
  Again, I benefit from a somewhat easy to setup CI pipeline thanks to
  <a href="https://github.com/cachix/install-nix-action">install-nix</a>, it's a copy of what I already do locally. And you can also benefit
  from faster builds with the <a href="https://github.com/DeterminateSystems/magic-nix-cache">magic-nix-cache</a>.
  </p>

  <div class="org-src-container">
  <pre class="src src-yaml">      - name: Install Nix
  uses: cachix/install-nix-action@v27

  - name: Install Nix Cache
  uses: DeterminateSystems/magic-nix-cache-action@main

  - name: Build website
  run: |
  mkdir -p "$HOME/.emacs.d/"
  touch "$HOME/.emacs.d/.org-id-locations"
  nix develop .#ci -c just build

  - name: Deploy
  uses: peaceiris/actions-gh-pages@v4
  with:
  github_token: ${{ secrets.GITHUB_TOKEN }}
  publish_dir: ./public
  </pre>
  </div>
  </div>
  </div>
  <div id="outline-container-ID-a6d4d3ea-b867-426b-81e1-c7b7b04cdffa" class="outline-3">
  <h3 id="ID-a6d4d3ea-b867-426b-81e1-c7b7b04cdffa">What is Still Missing</h3>
  <div class="outline-text-3" id="text-orgef9a9e0">
  <ul class="org-ul">
  <li>Anki-Like Flashcards: With either <a href="https://orgmode.org/worg/org-contrib/org-drill.html%5C">org-drill</a> or <a href="https://www.leonrische.me/fc/index.html">org-fc</a>.</li>

  <li>Integration with <a href="https://github.com/jkitchin/org-ref">org-ref</a>: <code>org-ref</code> offers a suite of tools that would make
  keeping track of references easier as the number of notes and posts increases.</li>

  <li>Remove some of the Polyglot Templating: Although the polyglot usage of
  different programming languages here was a good way to show some of orgmode's
  source block features, I know my usage of <code>F#</code> is unecessary, I could have done
  the same in pure <code>elisp</code>, but I still suck at it.</li>

  <li>Not related to the blog itself, but <a href="https://orgmode.org/manual/Agenda-Views.html">org-agenda</a> looks slick.</li>
  </ul>
  </div>
  </div>
  ]]></description>
</item>
<item>
  <title>Notable Mentions</title>
  <link>https://schonfinkel.github.io/blog/20241230-the_road_to_emacs_maximalism.html#org010fc3c</link>
  <author>runner@runnervm3ublj (Marcos Benevides)</author>
  <guid isPermaLink="false">86fc8bb6-088e-41cb-b82f-e8fe5eeb81b9</guid>
  <pubDate>Mon, 30 Dec 2024 21:00:00 +0000</pubDate>

  <description><![CDATA[<div id="outline-container-ID-536c9512-efd1-4999-bd89-4cef6ab304d5" class="outline-3">
  <h3 id="ID-536c9512-efd1-4999-bd89-4cef6ab304d5">Hugo</h3>
  <div class="outline-text-3" id="text-org3c8b215">
  <p>
  This blog was originally fully integrated with<a href="https://gohugo.io/"> hugo</a> and <a href="https://ox-hugo.scripter.co/">ox-hugo</a> (first stolen
  from <a href="https://github.com/ratsclub">my close friend</a>), but eventually I've started facing issues since the way I
  organize files (one per post) is not recommended by ox-hugo. The "per-post"
  setup actually worked, but <code>hugo</code> is also a project that moves very fast and I
  quickly faced a situation where upgrading it broke my workflow, luckily I
  develop in a sandbox environment and was able to ignore this versioning issue
  for a couple months.
  </p>
  </div>
  </div>
  <div id="outline-container-ID-fcd17701-eefc-423f-acaf-71ff4167112c" class="outline-3">
  <h3 id="ID-fcd17701-eefc-423f-acaf-71ff4167112c">Quartz</h3>
  <div class="outline-text-3" id="text-org426da4c">
  <p>
  Similar to <code>hugo</code>, although <a href="https://quartz.jzhao.xyz/">Quartz</a> is also built to support <a href="https://obsidian.md/">Obsidian</a>-like notes.
  </p>
  </div>
  </div>
  <div id="outline-container-ID-c2a8a85b-360a-4ae0-ae5f-52f2c076a1ca" class="outline-3">
  <h3 id="ID-c2a8a85b-360a-4ae0-ae5f-52f2c076a1ca">Emanote</h3>
  <div class="outline-text-3" id="text-org3a0b22c">
  <p>
  Before doing the full refactor and moving it back to a pure <a href="https://orgmode.org/manual/Publishing.html">org-publish</a>
  workflow, I found out about <a href="https://emanote.srid.ca/">emanote</a>. It is similar to Quartz, but it feels
  overall better since the license is <code>AGPL v3</code>. It's also built atop of Markdown,
  but there are <a href="https://github.com/srid/emanote/blob/master/docs/guide/orgmode.org">steps</a> on how to configure this to use <code>org</code> as well. May be a good
  choice for people already familiar with Haskell and Nix.
  </p>
  </div>
  </div>
  ]]></description>
</item>
<item>
  <title>Conclusion</title>
  <link>https://schonfinkel.github.io/blog/20241230-the_road_to_emacs_maximalism.html#org8921ce5</link>
  <author>runner@runnervm3ublj (Marcos Benevides)</author>
  <guid isPermaLink="false">98eed0a6-2a6c-4a75-a019-681adc747df5</guid>
  <pubDate>Mon, 30 Dec 2024 21:00:00 +0000</pubDate>

  <description><![CDATA[<p>
  While I haven't moved all my development workflow to <code>Emacs</code> (it might be a matter
  of time), <code>Emacs</code> already stole all my note-taking and blogging capabilities and
  I'll probably stick with it for a long time. I still hope <code>Neovim</code> gets something
  similar, it is already a huge improvement above vanilla <code>vim</code> offered thanks to
  many new features (and allowing a <a href="https://neovim.io/doc/user/lua-guide.html">real language</a> for configuration instead of
  <code>VimL</code>). There is also some work being done in <a href="https://github.com/nvim-orgmode/orgmode">replicating org</a> using <code>lua</code>, but it
  would be interesting to see if the community can pull some similar plugins as
  well.
  </p>
  ]]></description>
</item>
<item>
  <title>References</title>
  <link>https://schonfinkel.github.io/blog/20241230-the_road_to_emacs_maximalism.html#org59fd534</link>
  <author>runner@runnervm3ublj (Marcos Benevides)</author>
  <guid isPermaLink="false">41aa38de-4163-4905-acbe-bac37bcd16e4</guid>
  <pubDate>Mon, 30 Dec 2024 21:00:00 +0000</pubDate>

  <description><![CDATA[<style>.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}</style><div class="csl-bib-body">
  <div class="csl-entry"><a id="citeproc_bib_item_1"></a>Knuth, Donald Ervin. 1984. “Literate Programming.” <i>The Computer Journal</i> 27 (2): 97–111.</div>
  <div class="csl-entry"><a id="citeproc_bib_item_2"></a>Schulte, Eric, Dan Davison, Thomas Dye, and Carsten Dominik. 2012. “A Multi-Language Computing Environment for Literate Programming and Reproducible Research.” <i>Journal of Statistical Software</i> 46: 1–24.</div>
  </div>
  ]]></description>
</item>
</channel>
</rss>
